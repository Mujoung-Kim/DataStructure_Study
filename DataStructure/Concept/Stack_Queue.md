# 스택(Stack)

## 개념
 - 제한적으로 접근할 수 있는 나열 구조이다.
 - 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out)형식의 자료구조이다.

<br>

## 연산
 - LIFO(Last In First Out)을 따른다. 즉 가장 최근에 스택에 추가한 항목이 가장 먼저 제거될 항목이다.
 - 필요 기능
   - `push(item)` : item 하나를 스택의 가장 윗 부분에 추가한다.
   - `pop()` : 스택에서 가장 위에 있는 항목을 제거한다.
   - `peek() or top()` : 스택의 가장 위에 있는 항목을 반환한다.
   - `empty() or isEmpty()` : 스택이 비어 있을 때에 true를 반환한다.

<br>

## 구현
 - 문제의 종류에 따라 배열보다 스택에 데이터를 저장하는 것이 더 적합한 방법일 수 있다.
   - 배열과 달리 스택은 상수 시간에 i번째 항목에 접근할 수 없다.
   - 하지만 스택에서 데이터를 추가하거나 삭제하는 연산은 상수 시간에 가능하다.
   - 배열처럼 원소들을 하나씩 옆으로 밀어 줄 필요가 없다.
   > 스택(Stack)은 연결리스트로 구현할 수 있다. 연결리스트의 같은 방향에서 아이템을 추가하고 삭제하도록 구현한다.

<br>

## 사용 사례
 - 재귀 알고리즘
 - 웹 브라우저 방문기록 (뒤로가기)
 - 실행 취소 (undo)
 - 역순 문자열 만들기
 - 수식의 괄호 검사 (연산자 우선순위 표현을 위한 괄호 검사)
   > Ex) 올바른 괄호 문자열(VPS, Valid Parenthesis String) 판단하기
 - 후위 표기법 계산

<br>

### 재귀알고리즘
 - 재귀적으로 함수를 호출해야 하는 경우에 임시 데이터를 스택에 넣어준다.
 - 재귀함수를 빠져 나와 퇴각 검색(backtrack)을 할 때는 스택에 넣어 두었던 임시 데이터를 빼줘야 한다.
 - 스택은 이런 일련의 행위를 직관적으로 가능하게 해준다.
 - 스택은 재귀 알고리즘을 반복적 형태(iterative)를 통해서 구현할 수 있게 해준다.
<br><br>


# 큐(Queue)

## 개념
 - 스택과 마찬가지로 삽입과 삭제의 위치와 방법이 제한되어 있는 자료구조이지만 한쪽 끝에서 삽입작업이 이루어지고 반대쪽 끝에서는 삭제 작업이 이루어지는 구조이다.
 - 데이터가 삽입된 순서대로 삭제되는 FIFO(First In First Out)구조이다.

<br>

## 연산
 - FIFO(First In First Out)구조로 입력된 데이터 순서대로 처리되는 방식이다.
 - 필요 기능
   - `enqueue()` : 큐 맨 뒤에 어떠한 요소를 추가, 마지막으로 온 손님에게 번호표 발부한다.
   - `dequeue()` : 큐 맨 앞쪽의 요소를 삭제, 창구에서 서비스를 받은 손님의 번호표를 대기목록에서 삭제한다.
   - `peek()` : `front`에 위치한 데이터를 읽음, 다음 서비스를 받을 손님이 누구인지 확인한다.
   - `front()` : 큐의 맨 앞의 위치(인덱스), 다음 서비스를 받을 손님의 번호
   - `rear()` : 큐의 맨 뒤의 위치(인덱스), 마지막에 온 손님의 번호

<br>

## 구현
 - 큐가 꽉 차서 더 이상 자료를 넣을 수 없는 경우를 오버플로우(Overflow), 큐가 비어 있어 자료를 꺼낼 수 없는 경우를 언더플로우(Underflow)라고 한다.
 - 오버플로우 발생을 보완하기 위해 환형 큐와 연결리스트로 구현할 수 있다.

<br>

## 사용 사례
 - 은행창구 번호표 대기
   > 빠른 번호표를 가진 사람이 먼저 업무를 봅니다.
 - 프린터 출력
   > 가장 먼저 대기열에 오른 프린트가 먼저 출력됩니다.
 - 컴퓨터 운영체제의 테스크 스케쥴링
   > 가장 간단한 형태의 선입선 처리 스케쥴링 정책
 - 너비 우선 탐색(BFS) 알고리즘

<br>

<!-- ### 너비 우선 탐색 알고리즘(BFS, Breadth-First Search) -->